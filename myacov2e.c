/*

This program computes E as 3G* where G* is the magnitude of the complex Fourier
transform of the stress autocovariance.  The stress autocovariance is computed
using acf.py, which reads in all six off-diagonal stress tensor elements vs timestep
generated by 'gmx energy'. Stress tensor components are in units of bars, and
therefore the autocovariance is in units of bar^2.  This program
reads in the autocovariance into the array c_bar2 and uses the GSL real FFT
to compute the finite Fourier transform.  Negative-frequency coefficients are ignored, 
meaning that coefficients 0 to n/2, where n is the number of lags in the autocovariance, 
are used, and those with indices higher than n/2 are ignored.  Finally, this program
generates a column-oriented output file containing the lag index (0, 1, ...), the
frequency in ps, and 3G* in units of Pa.

Cameron Abrams, cfa22@drexel.edu

compile as
> gcc -O5 -o myacov2e myacov2e.c -lm -lgsl -lgslcblas


*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_fft_real.h>
#include <gsl/gsl_fft_halfcomplex.h>

/* This function just reads in the autocovariance data file, skipping data not in the 
   requested lag domain [0,lmx], and using a stride.  Note that the data at lag=0 is ALWAYS
   included. */
int get_data(char * fn, double ** x, double ** data, int n, double lmx, int stride) {
    int i=0, j=0, nlines=0;
    char thisline[255];
    double thisl,thisv;
    FILE * fp = fopen(fn,"r");
    i=0;
    j=0;
    nlines=0;
    while (fgets(thisline,255,fp)) {
        nlines++;
        if (thisline[0]!='#') {
            if (i%stride==0) {
                sscanf(thisline,"%le %le\n",&thisl,&thisv);
                if (thisl<=lmx) {
                    j++;
                }
            }
            i++;
        }
    }
    fclose(fp);
    printf("Among %d lines, %d acceptable lag values less than %e with stride %d exist.\n",
           nlines,j,lmx,stride);
    (*data)=(double*)malloc(j*sizeof(double));
    (*x)=(double*)malloc(j*sizeof(double));
    fp = fopen(fn,"r");
    j=0;
    i=0;
    while (fgets(thisline,255,fp)) {
        if (thisline[0]!='#') {
            if (i%stride==0) {
                sscanf(thisline,"%le %le\n",&thisl,&thisv);
                if (thisl<=lmx) {
                    (*x)[j]=thisl;
                    (*data)[j]=thisv;
                    j++;
                }
            }
            i++;
        }
    }
    printf("%d lag values read in. Done.\n",j);
    fclose(fp);
    return j;   
}

int main (int argc, char * argv[]) {
  int i, n=40000001;
  double lag_max=10000.0; // ps
  double * c_bar2;
  double * lag_ps;
  double * cc=(double*)malloc(n*sizeof(double));
  double delta_ps=0.0,freq;
  double fac_bar=0.0;
  double Pa_per_bar=1.e5;  // Pascals per bar
  double k_kJmolK = 8.3144621e-3; // Boltzmann constant in kJ/mol/K
  double bar_kJmolnm3 = 16.6;  // bar per (kJ/mol/m^3)
  /* default values */
  double L_nm = 8.16018, V_nm3;
  double T_K = 600.0;
  double kT_kJmol;
  double mag;
  FILE * fp;
  int stride = 1;
  gsl_fft_real_wavetable * real;
  gsl_fft_real_workspace * work;
  gsl_complex_packed_array c=cc;
  char * outfile ="fft.dat";
  
  for (i=1;i<argc;i++) {
      if (!strcmp(argv[i],"-lag-max")) lag_max=atof(argv[++i]);
      else if (!strcmp(argv[i],"-T")) T_K=atof(argv[++i]);
      else if (!strcmp(argv[i],"-L")) L_nm=atof(argv[++i]);
      else if (!strcmp(argv[i],"-stride")) stride=atoi(argv[++i]);
      else if (!strcmp(argv[i],"-o")) outfile=argv[++i];
  }
  V_nm3 = L_nm*L_nm*L_nm;  // volume in nm^3
  kT_kJmol = T_K*k_kJmolK;  // kT in kJ/mol
  fac_bar = V_nm3/kT_kJmol/bar_kJmolnm3; // V/kT in bar^{-1}

  printf("Reading %s...\n",argv[argc-1]);fflush(stdout);
  n=get_data(argv[argc-1],&lag_ps,&c_bar2,n,lag_max,stride);
  delta_ps=lag_ps[1]-lag_ps[0];
  printf("Delta: %e ps\n",delta_ps);
  printf("Computing FFT...\n");fflush(stdout);
  work=gsl_fft_real_workspace_alloc(n);
  real=gsl_fft_real_wavetable_alloc(n);
  gsl_fft_real_transform(c_bar2,1,n,real,work);
  gsl_fft_real_wavetable_free(real);
  printf("Unpacking coefficients...\n");fflush(stdout);
  gsl_fft_halfcomplex_unpack(c_bar2,c,1,n);
  // c[i] and c[i+1] are now real and imaginary coefficients for i/2'th mode
  printf("Writing %s\n",outfile);fflush(stdout);
  fp = fopen(outfile,"w");
  fprintf(fp,"# i freq(1/ps) E=3G*(Pa)\n");
  for (i = 0; i < n/2; i+=2) {
    freq=i?1.0/(i*delta_ps):0.0;  // units of 1/ps
    mag=sqrt(c[i]*c[i]+c[i+1]*c[i+1]);  // units of bar^2
    fprintf(fp,"%d %le %le\n", i, freq, 3*freq*delta_ps*fac_bar*1.e5*mag);
  }

  gsl_fft_real_workspace_free (work);
  return 0;
}